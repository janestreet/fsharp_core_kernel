#light





namespace Core_kernel
    
    module Either =
        
        type ('a,'b) t =
            | First of 'a
            | Second of 'b

namespace Core_kernel
    
    module List =
        
        type 'a t = 'a list
        
        val partition_map:
          f: ('a -> ('b,'c) Either.t) -> 'a list -> 'b list * 'c list
        
        val partition_tf: f: ('a -> bool) -> ('a list -> 'a list * 'a list)
        
        val transpose: 'a list list -> 'a list list option
        
        val rev_filter_map: f: ('a -> 'b option) -> l: 'a list -> 'b list
        
        val filter_map: f: ('a -> 'b option) -> 'a list -> 'b list
        
        val filter_opt: 'a option list -> 'a list

namespace Core_kernel
    
    module Result =
        
        [<Struct>]
        type ('a,'b) t = Result<'a,'b>
        
        val ok_exn: Result<'a,'b> -> 'a
        
        [<Sealed>]
        type ResultBuilder =
            
            new: unit -> ResultBuilder
            
            member Bind: Result<'a,'b> * ('a -> Result<'c,'b>) -> Result<'c,'b>
            
            member Return: 'a -> Result<'a,'?22762>
            
            member ReturnFrom: 'a -> 'a
            
            member TryFinally: x: 'a * f: (unit -> unit) -> 'a
            
            member Using: 'a * ('a -> 'b) -> 'b when 'a :> System.IDisposable
            
            member Zero: unit -> Result<unit,'?22772>
        
        val let_syntax: ResultBuilder
        
        val iter: Result<'a,'?22774> -> ('a -> unit) -> unit
        
        val join: Result<Result<'a,'b>,'b> -> Result<'a,'b>
        
        val to_either: _arg1: Result<'a,'b> -> ('a,'b) Either.t
        
        val combine_errors: Result<'a,'b> list -> Result<'a list,'b list>
        
        val all: Result<'a,'b> list -> Result<'a list,'b>

namespace Core_kernel
    
    module Sexp =
        
        type t =
            Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Sexp.T.t
        
        val bin_t:
          Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Sexp.T.t Bin_prot.Type_class.t

namespace Core_kernel
    
    module Error =
        
        type t =
            Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val bin_t:
          Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t Bin_prot.Type_class.t
        
        val to_string:
          Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
            -> string
        
        val of_list:
          Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t list
            -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val create_string:
          x: string
            -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val create_with_path_and_line:
          message: string -> path: string -> line: int
            -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val tag:
          string
          -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
            -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val tagf:
          Printf.StringFormat<'a,
                              (Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
                                 -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t)>
            -> 'a
        
        [<Sealed>]
        type Of =
            
            new: unit -> Of
            
            static member
              format: format: Printf.StringFormat<'a,t> * path: string *
                      line: int -> 'a
            
            static member
              string: message: string * path: string * line: int
                        -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val create:
          x: string
            -> Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
        
        val createf:
          format: Printf.StringFormat<'a,
                                      Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t>
            -> 'a
        
        val raise:
          Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t
            -> 'a

namespace Core_kernel
    
    module Or_error =
        
        [<Struct>]
        type 'a t = Result<'a,Error.t>
        
        val combine_errors:
          ('a,Error.t) Result.t list -> Result<'a list,Error.t>
        
        val tagf:
          Printf.StringFormat<'a,(Result<'b,Error.t> -> Result<'b,Error.t>)>
            -> 'a
        
        val bin_t:
          'a Bin_prot.Type_class.t
            -> Result<'a,
                      Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Src.Error.T.t> Bin_prot.Type_class.t
        
        [<Sealed>]
        type Error =
            
            new: unit -> Error
            
            static member
              format: format: Printf.StringFormat<'a,Result<'b,Error.t>> *
                      path: string * line: int -> 'a
            
            static member
              string: message: string * path: string * line: int
                        -> Result<'?22797,Error.t>
        
        val try_with: (unit -> 'a) -> Result<'a,Error.t>

namespace Core_kernel
    
    module Sequencer =
        
        type 'a t = | T of 'a
        
        val create: t: 'a -> 'a t
        
        val with_: 'a t -> ('a -> 'b) -> 'b when 'a: not struct

namespace Core_kernel
    
    module Auto_reset_event =
        
        type t = System.Threading.AutoResetEvent
        
        val wait_one: t -> unit
        
        val wait_n: t -> n: int -> unit
        
        val set: t -> unit

namespace Core_kernel
    
    module Time_source =
        
        type t =
            
            abstract now: unit -> System.DateTime
            
            abstract sleep_for: System.TimeSpan -> unit
        
        type time_source = t
        
        module Wall_clock =
            
            type t =
                interface time_source
                
                new: unit -> t
        
        module Controllable =
            
            type t =
                interface System.IDisposable
                interface time_source
                
                new: System.DateTime -> t
                
                member advance_after_sleep_by: System.TimeSpan -> unit
                
                member advance_after_sleep_to: System.DateTime -> unit
                
                member advance_immediately_by: System.TimeSpan -> unit
                
                member advance_immediately_to: System.DateTime -> unit
        
        module Constant =
            
            type t =
                interface time_source
                
                new: System.DateTime -> t
            
            val dotnet_epoch: t

namespace Core_kernel
    
    module Dictionary =
        
        type t<'key,'value> = System.Collections.Generic.Dictionary<'key,'value>
        
        val of_alist_exn:
          ('key * 'value) list
          -> System.Collections.Generic.IEqualityComparer<'key>
            -> System.Collections.Generic.Dictionary<'key,'value>
        
        val find: t<'key,'value> -> 'key -> 'value option
        
        val remove: t<'key,'value> -> 'key -> unit
        
        val set: t<'key,'value> -> 'key -> 'value -> unit
        
        val iter: ('key -> 'value -> unit) -> t<'key,'value> -> unit

namespace Core_kernel
    
    module Concurrent_dictionary =
        
        type t<'key,'value> =
            System.Collections.Concurrent.ConcurrentDictionary<'key,'value>
        
        val find: 'key -> t<'key,'value> -> 'value option
        
        val remove_exn: 'key -> t<'key,'value> -> 'value
        
        val add_exn: 'key -> 'value -> t<'key,'value> -> unit
        
        val update:
          'key -> ('value option -> 'value) -> t<'key,'value> -> 'value

namespace Core_kernel
    
    module Thread =
        
        type t = System.Threading.Thread
        
        val spawn: desc: string -> (unit -> unit) -> System.Threading.Thread
        
        val spawn_and_ignore: desc: string -> (unit -> unit) -> unit

namespace Core_kernel
    
    module Set =
        
        type t<'a when 'a: comparison> = Set<'a>
        
        val if_nonempty:
          f: (Set<'a> -> 'b) -> t: Set<'a> -> 'b option when 'a: comparison
        
        val maxElement: Set<'a> -> 'a option when 'a: comparison
        
        val minElement: Set<'a> -> 'a option when 'a: comparison

namespace Core_kernel
    
    module Map =
        
        type t<'key,'value when 'key: comparison> = Map<'key,'value>
        
        val values: Map<'?22869,'value> -> seq<'value> when '?22869: comparison
        
        val change:
          'key -> f: ('value option -> 'value option) -> Map<'key,'value>
            -> Map<'key,'value> when 'key: comparison
        
        val merge_skewed:
          combine: ('key -> 'value -> 'value -> 'value) -> t<'key,'value>
          -> t<'key,'value> -> Map<'key,'value> when 'key: comparison
        
        val merge_skewed_left:
          t<'key,'value> -> t<'key,'value> -> Map<'key,'value>
            when 'key: comparison

namespace Core_kernel
    
    module Blocking_queue =
        
        type 'a queue = System.Collections.Concurrent.BlockingCollection<'a>
        
        module Writer =
            
            type 'a t = | T of 'a queue
            
            val write: 'a t -> 'a -> unit
        
        module Reader =
            
            type 'a t = | T of 'a queue
            
            val read: 'a t -> 'a
        
        val create: unit -> 'a Reader.t * 'a Writer.t

namespace Core_kernel
    
    module Integer =
        
        module ActivePatterns =
            
            val (|ParseInteger|_|) : string -> int option

namespace Core_kernel
    
    module Regex =
        
        module ActivePatterns =
            
            val (|ParseRegex|_|) :
              regex: string -> string: string -> string list option

namespace Core_kernel
    
    module Host_and_port =
        
        type t =
            {
              host: string
              port: int
            }
        
        val create: string -> int -> t
        
        module Parser =
            
            val of_string_exn: str: string -> t
        
        val of_string_exn: string -> t

namespace Core_kernel
    
    module Time_float =
        
        module Stable =
            
            module V1 =
                
                [<Struct>]
                type t =
                    Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Unix.Time_float.Stable.V1.t
        
        [<Struct>]
        type t = Stable.V1.t
        
        val epoch: System.DateTime
        
        val to_datetime: float -> System.DateTime
        
        val of_datetime: System.DateTime -> float
        
        val of_excel_time: oa_date: float -> float
        
        val to_excel_time: float -> float

namespace Core_kernel
    
    module Time_ns =
        
        module Stable =
            
            module V1 =
                
                [<Struct>]
                type t =
                    Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Unix.Time_ns.Stable.V1.t
        
        [<Struct>]
        type t = Stable.V1.t
        
        val epoch: System.DateTime
        
        val to_datetime: int64 -> System.DateTime
        
        val of_datetime: System.DateTime -> int64
        
        module Span =
            
            [<Struct>]
            type t =
                Bin_prot_generated_types.Lib.Dotnet.Core_with_dotnet.Unix.Time_ns.Stable.Span.V2.t
            
            val of_sec: float -> int64
            
            val to_sec: t -> float
            
            val to_time_span: t -> System.TimeSpan

namespace Core_kernel
    
    module Log =
        
        val printfn: Printf.TextWriterFormat<'a> -> 'a
        
        val global_counter:
          System.Collections.Concurrent.ConcurrentDictionary<(string * int),int>
        
        [<Sealed>]
        type Limited =
            
            new: unit -> Limited
            
            static member
              printfn_every_n: n: int * format: Printf.StringFormat<'a,unit> *
                               path: string * line: int -> 'a

namespace Core_kernel
    
    module Thread_safe_run_once =
        
        type t = | T of int ref
        
        val create: unit -> t
        
        val run_if_first_time: t -> f: (unit -> unit) -> unit
        
        val ran: t -> bool

namespace Core_kernel
    
    module Bimap =
        
        type t<'a,'b> =
            {
              a_to_b: System.Collections.Generic.Dictionary<'a,'b>
              b_to_a: System.Collections.Generic.Dictionary<'b,'a>
            }
        
        val create: unit -> t<'a,'b> when 'a: equality and 'b: equality
        
        val try_find_a: t<'a,'b> -> 'b -> 'a option
        
        val try_find_b: t<'a,'b> -> 'a -> 'b option
        
        val add: t<'a,'b> -> 'a -> 'b -> unit
        
        val remove_by_a: t<'a,'b> -> 'a -> unit
        
        val remove_by_b: t<'a,'b> -> 'b -> unit

namespace Core_kernel
    
    module Configuration_manager =
        
        val try_get: key: string -> string option
        
        val get_exn: key: string -> string

namespace Core_kernel
    
    module Hostname =
        
        type t = | T of string
        
        val to_string: t -> string
        
        val of_string: string -> t
        
        val current: unit -> t

namespace Core_kernel
    
    module IPAddress =
        
        type t = System.Net.IPAddress
        
        val ipv4_of_hostname: Hostname.t -> Result<System.Net.IPAddress,Error.t>

namespace Core_kernel
    
    module User_groups =
        
        type t = string list
        
        val windows_groups: unit -> string list
        
        val linux_groups: unit -> string list Or_error.t
        
        val of_current_user: unit -> Result<string list,Error.t>

namespace Core_kernel
    
    module Command =
        
        module Arg_type =
            
            type 'a t =
                { parse: string -> 'a }
            
            val create: (string -> 'a) -> 'a t
        
        module Flag =
            
            type 'a t =
                {
                  read: string list -> 'a
                  name: string
                  doc: string
                  required: bool
                  no_arg: bool
                }
            
            val required: 'a Arg_type.t -> string -> string -> 'a t
            
            val optional: 'a Arg_type.t -> string -> string -> 'a option t
            
            val no_arg: string -> string -> bool t
        
        module Parser =
            
            type 'a t = string list -> 'a * string list
            
            val bind:
              x: 'a t -> f: ('a -> string list -> 'b * string list)
              -> args: string list -> 'b * string list
            
            val map:
              x: 'a t -> f: ('a -> 'b) -> args: string list -> 'b * string list
            
            val both:
              x: 'a t -> y: 'b t -> args: string list -> ('a * 'b) * string list
            
            val return_: x: 'a -> args: string list -> 'a * string list
            
            val zero: unit -> args: string list -> unit * string list
        
        module Param =
            
            type 'a t =
                {
                  parser: 'a Parser.t
                  flags: (string * string) list
                  anons: string list
                }
            
            val parse: 'a t -> string list -> 'a * string list
            
            val flag: 'a Flag.t -> 'a t
            
            val bind: 'a t -> ('a -> 'b t) -> 'b t
            
            val map: 'a t -> ('a -> 'b) -> 'b t
            
            val both: 'a t -> 'b t -> ('a * 'b) t
            
            val return_: 'a -> 'a t
            
            val zero: unit -> unit t
            
            [<Sealed>]
            type ResultBuilder =
                
                new: unit -> ResultBuilder
                
                member Bind: 'a t * ('a -> 'b t) -> 'b t
                
                member BindReturn: 'a t * ('a -> 'b) -> 'b t
                
                member MergeSources: 'a t * 'b t -> ('a * 'b) t
                
                member Return: 'a -> 'a t
                
                member Zero: unit -> unit t
            
            val let_syntax: ResultBuilder
        
        val run_exn: unit Param.t -> string list -> int
        
        val run: unit Param.t -> string list -> int

